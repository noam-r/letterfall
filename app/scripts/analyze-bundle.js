#!/usr/bin/env node\n\n/**\n * Bundle size analysis script\n * Analyzes the built bundle to verify size optimizations\n */\n\nconst fs = require('fs');\nconst path = require('path');\nconst { execSync } = require('child_process');\n\n// Target bundle size reduction (40% from baseline)\nconst TARGET_REDUCTION = 0.4;\nconst BASELINE_SIZE_KB = 500; // Estimated baseline\nconst TARGET_SIZE_KB = BASELINE_SIZE_KB * (1 - TARGET_REDUCTION);\n\n/**\n * Get file size in KB\n */\nfunction getFileSizeKB(filePath) {\n  try {\n    const stats = fs.statSync(filePath);\n    return Math.round(stats.size / 1024 * 100) / 100;\n  } catch (error) {\n    return 0;\n  }\n}\n\n/**\n * Analyze bundle directory\n */\nfunction analyzeBundleDirectory(distPath) {\n  const results = {\n    totalSize: 0,\n    jsSize: 0,\n    cssSize: 0,\n    chunks: [],\n    assets: []\n  };\n\n  if (!fs.existsSync(distPath)) {\n    console.error(`‚ùå Distribution directory not found: ${distPath}`);\n    return results;\n  }\n\n  const files = fs.readdirSync(distPath);\n  \n  files.forEach(file => {\n    const filePath = path.join(distPath, file);\n    const stats = fs.statSync(filePath);\n    \n    if (stats.isFile()) {\n      const sizeKB = getFileSizeKB(filePath);\n      results.totalSize += sizeKB;\n      \n      const asset = {\n        name: file,\n        size: sizeKB,\n        type: path.extname(file)\n      };\n      \n      if (file.endsWith('.js')) {\n        results.jsSize += sizeKB;\n        if (file.includes('chunk') || file.includes('vendor')) {\n          results.chunks.push(asset);\n        }\n      } else if (file.endsWith('.css')) {\n        results.cssSize += sizeKB;\n      }\n      \n      results.assets.push(asset);\n    }\n  });\n  \n  // Sort assets by size (largest first)\n  results.assets.sort((a, b) => b.size - a.size);\n  results.chunks.sort((a, b) => b.size - a.size);\n  \n  return results;\n}\n\n/**\n * Check if code splitting is working\n */\nfunction checkCodeSplitting(results) {\n  const hasChunks = results.chunks.length > 0;\n  const hasVendorChunk = results.chunks.some(chunk => \n    chunk.name.includes('vendor') || chunk.name.includes('node_modules')\n  );\n  const hasLazyChunks = results.chunks.some(chunk => \n    chunk.name.includes('lazy') || chunk.name.includes('async')\n  );\n  \n  return {\n    hasChunks,\n    hasVendorChunk,\n    hasLazyChunks,\n    chunkCount: results.chunks.length\n  };\n}\n\n/**\n * Generate bundle analysis report\n */\nfunction generateReport(results) {\n  const splitting = checkCodeSplitting(results);\n  const sizeReduction = ((BASELINE_SIZE_KB - results.totalSize) / BASELINE_SIZE_KB) * 100;\n  const meetsTarget = results.totalSize <= TARGET_SIZE_KB;\n  \n  console.log('\\nüì¶ Bundle Size Analysis Report');\n  console.log('==============================');\n  \n  console.log('\\nüìä Size Metrics:');\n  console.log(`   Total Bundle Size: ${results.totalSize} KB`);\n  console.log(`   JavaScript: ${results.jsSize} KB (${Math.round(results.jsSize / results.totalSize * 100)}%)`);\n  console.log(`   CSS: ${results.cssSize} KB (${Math.round(results.cssSize / results.totalSize * 100)}%)`);\n  \n  console.log('\\nüéØ Performance Targets:');\n  console.log(`   Baseline Size: ${BASELINE_SIZE_KB} KB`);\n  console.log(`   Target Size: ${TARGET_SIZE_KB} KB (${TARGET_REDUCTION * 100}% reduction)`);\n  console.log(`   Actual Reduction: ${sizeReduction.toFixed(1)}%`);\n  console.log(`   Target Met: ${meetsTarget ? '‚úÖ Yes' : '‚ùå No'}`);\n  \n  console.log('\\nüß© Code Splitting Analysis:');\n  console.log(`   Total Chunks: ${splitting.chunkCount}`);\n  console.log(`   Has Vendor Chunk: ${splitting.hasVendorChunk ? '‚úÖ' : '‚ùå'}`);\n  console.log(`   Has Lazy Chunks: ${splitting.hasLazyChunks ? '‚úÖ' : '‚ùå'}`);\n  \n  if (results.chunks.length > 0) {\n    console.log('\\nüìÅ Chunk Breakdown:');\n    results.chunks.forEach(chunk => {\n      console.log(`   ${chunk.name}: ${chunk.size} KB`);\n    });\n  }\n  \n  console.log('\\nüìã Largest Assets:');\n  results.assets.slice(0, 10).forEach(asset => {\n    console.log(`   ${asset.name}: ${asset.size} KB`);\n  });\n  \n  // Recommendations\n  console.log('\\nüí° Recommendations:');\n  if (!meetsTarget) {\n    console.log('   ‚ö†Ô∏è  Bundle size exceeds target. Consider:');\n    console.log('      - Further code splitting');\n    console.log('      - Tree shaking optimization');\n    console.log('      - Asset compression');\n  }\n  \n  if (!splitting.hasVendorChunk) {\n    console.log('   ‚ö†Ô∏è  No vendor chunk detected. Consider separating vendor code.');\n  }\n  \n  if (!splitting.hasLazyChunks) {\n    console.log('   ‚ö†Ô∏è  No lazy chunks detected. Consider implementing lazy loading.');\n  }\n  \n  if (results.jsSize > results.totalSize * 0.8) {\n    console.log('   ‚ö†Ô∏è  JavaScript dominates bundle size. Consider code splitting.');\n  }\n  \n  return {\n    totalSize: results.totalSize,\n    meetsTarget,\n    sizeReduction,\n    splitting\n  };\n}\n\n/**\n * Main analysis function\n */\nfunction main() {\n  console.log('üîç Starting bundle size analysis...');\n  \n  const distPath = path.join(__dirname, '../dist');\n  \n  // Build the project first\n  try {\n    console.log('üèóÔ∏è  Building project...');\n    execSync('npm run build', { cwd: path.join(__dirname, '..'), stdio: 'inherit' });\n  } catch (error) {\n    console.error('‚ùå Build failed:', error.message);\n    process.exit(1);\n  }\n  \n  // Analyze the bundle\n  const results = analyzeBundleDirectory(distPath);\n  const report = generateReport(results);\n  \n  // Exit with appropriate code\n  if (report.meetsTarget) {\n    console.log('\\nüéâ Bundle size analysis passed!');\n    process.exit(0);\n  } else {\n    console.log('\\n‚ùå Bundle size analysis failed!');\n    process.exit(1);\n  }\n}\n\n// Run if called directly\nif (require.main === module) {\n  main();\n}\n\nmodule.exports = {\n  analyzeBundleDirectory,\n  generateReport,\n  checkCodeSplitting\n};\n"